tool_name: execute_sequence
arguments:
  variables:
    release_url:
      type: string
      label: GitHub Release asset URL (zip)
      default: "https://github.com/mediar-ai/terminator/releases/latest/download/terminator-browser-extension.zip"

  selectors:
    # --- Selectores de UI (Inglés) ---
    address_bar: "role:Edit|name:Address and search bar"
    dev_mode_toggle: "role:Button|name:Developer mode"
    load_unpacked: "role:Button|name:Load unpacked"
    reload_button: "role:Button|name:Reload"
    extensions_doc: "role:Document|name:Extensions"

    # --- Selector de Perfil Genérico (Inglés) ---
    guest_mode_button: "role:Button|name:Guest mode"

    # --- Selectores de Diálogo (Inglés) ---
    folder_field: "role:Edit|name:Folder:"
    select_folder_btn: "role:Button|name:Select Folder"

  steps:
    # --- PASOS 1-3: PREPARACIÓN DE ARCHIVOS ---
    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const fs = require('fs');
          const path = require('path');
          const os = require('os');
          (async () => {
            const url = "${{release_url}}";
            if (!url || !url.trim()) throw new Error('release_url is empty');
            const tmp = (process.env.TEMP || os.tmpdir());
            const zipPath = path.join(tmp, 'terminator-browser-extension.zip');
            const destDir = path.join(tmp, 'terminator-bridge');
            try { fs.rmSync(destDir, { recursive: true, force: true }); } catch (_) {}
            try { fs.mkdirSync(destDir, { recursive: true }); } catch (e) { throw new Error('Failed to create dest dir: ' + e.message); }
            let res;
            let lastErr;
            for (let i = 0; i < 3; i++) {
              try {
                res = await fetch(url, { signal: AbortSignal.timeout(30000) });
                if (res.ok) break;
                lastErr = `Download failed: ${res.status}`;
              } catch (e) { lastErr = e.message; }
              await sleep(2000);
            }
            if (!res || !res.ok) { throw new Error(`Download failed after 3 attempts: ${lastErr}`); }
            const arrayBuf = await res.arrayBuffer();
            fs.writeFileSync(zipPath, Buffer.from(arrayBuf));
            console.log(`::set-env name=zip_path::${zipPath}`);
            return { set_env: { zip_path: zipPath } };
          })();

    - tool_name: run_command
      arguments:
        run: |
          $ErrorActionPreference = 'Stop'
          $zip = Join-Path $env:TEMP 'terminator-browser-extension.zip'
          $dest = Join-Path $env:TEMP 'terminator-bridge'
          if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
          New-Item -ItemType Directory -Force -Path $dest | Out-Null
          Expand-Archive -Path $zip -DestinationPath $dest -Force
        shell: powershell

    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const fs = require('fs');
          const path = require('path');
          const os = require('os');
          (async () => {
            const root = path.join(process.env.TEMP || os.tmpdir(), 'terminator-bridge');
            const stack = [root];
            let picked = null;
            while (stack.length) {
              const dir = stack.pop();
              let entries;
              try { entries = fs.readdirSync(dir, { withFileTypes: true }); } catch (_) { continue; }
              if (entries.some(e => e.isFile && e.name.toLowerCase() === 'manifest.json')) {
                picked = dir; break;
              }
              for (const e of entries) {
                if (e.isDirectory()) {
                  stack.push(path.join(dir, e.name));
                }
              }
            }
            const finalDir = picked || root;
            console.log(`::set-env name=extension_dir_text::${finalDir}`);
            return { set_env: { extension_dir_text: finalDir } };
          })();
      continue_on_error: false

    # --- PASOS 4-9: NAVEGACIÓN ROBUSTA ---

    - tool_name: navigate_browser
      arguments:
        url: "chrome://extensions"
        browser: "chrome"

    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          let profileWindow;
          try {
            profileWindow = await desktop.locator('role:Button|name:Guest mode').first(2500).catch(()=>null);
          } catch(e) { /* ignore */ }
          if (!profileWindow) {
            return { profile_handled: false };
          }
          try {
            const guestButton = await desktop.locator("${{ selectors.guest_mode_button }}").first(1000).catch(()=>null);
            if (guestButton) {
              await guestButton.click();
              return { profile_handled: true };
            }
            return { profile_handled: false };
          } catch (e) {
            return { profile_handled: false };
          }
      continue_on_error: true

    - tool_name: wait_for_element
      arguments:
        selector: "${{ selectors.address_bar }}"
        condition: "visible"
        timeout_ms: 5000
      continue_on_error: true

    - tool_name: click_element
      arguments:
        selector: "${{ selectors.address_bar }}"
      continue_on_error: true

    - tool_name: type_into_element
      arguments:
        selector: "${{ selectors.address_bar }}"
        text_to_type: "chrome://extensions"
        clear_before_typing: true
        verify_action: false
      continue_on_error: true

    - tool_name: press_key_global
      arguments:
        key: "{Enter}"
      continue_on_error: true

    # --- PASOS 10-17: CONFIGURACIÓN E INSTALACIÓN ---

    - tool_name: click_element
      arguments:
        selector: "${{ selectors.extensions_doc }}"
        timeout_ms: 10000
      continue_on_error: false

    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const toggleSel = "${{ selectors.dev_mode_toggle }}";
          const loadSel = "${{ selectors.load_unpacked }}";
          (async () => {
            let loadVisible = false;
            try {
              await desktop.locator(loadSel).first(500);
              loadVisible = true;
            } catch (_) { }
            if (!loadVisible) {
              const devToggle = await desktop.locator(toggleSel).first(3000);
              await devToggle.click();
              await desktop.locator(loadSel).first(3000);
            }
          })();
      continue_on_error: false

    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const extensionName = "Terminator Bridge";
          (async () => {
            try {
              const allElements = await desktop.locator("role:Group").all();
              for (let element of allElements) {
                try {
                  const name = await element.name();
                  const text = await element.value();
                  if ((name && name.includes(extensionName)) || (text && text.includes(extensionName))) {
                    const removeButton = await element.locator("role:Button|name:Remove").first();
                    await removeButton.click();
                    await sleep(250);
                    await desktop.press_key("{Enter}");
                    await sleep(500);
                    break;
                  }
                } catch (e) { continue; }
              }
            } catch (error) { }
          })();
      continue_on_error: true

    - tool_name: click_element
      arguments:
        selector: "${{ selectors.load_unpacked }}"
      continue_on_error: false

    - tool_name: wait_for_element
      arguments:
        selector: "${{ selectors.folder_field }}"
        condition: "visible"
        timeout_ms: 10000
      continue_on_error: false

    - tool_name: type_into_element
      arguments:
        selector: "${{ selectors.folder_field }}"
        text_to_type: "${{env.extension_dir_text}}"
        clear_before_typing: true
        verify_action: false
      continue_on_error: false

    - tool_name: click_element
      arguments:
        selector: "${{ selectors.select_folder_btn }}"
      continue_on_error: false

    - tool_name: wait_for_element
      arguments:
        selector: "${{ selectors.reload_button }}"
        condition: "visible"
        timeout_ms: 15000
      continue_on_error: false

  stop_on_error: true
