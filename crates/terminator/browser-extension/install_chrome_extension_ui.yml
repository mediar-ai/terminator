tool_name: execute_sequence
arguments:
  variables:
    release_url:
      type: string
      label: GitHub Release asset URL (zip)
      default: "https://github.com/mediar-ai/terminator/releases/latest/download/terminator-browser-extension.zip"

  selectors:
    address_bar: "role:Edit|name:Address and search bar"
    dev_mode_toggle: "role:Button|name:Developer mode"
    load_unpacked: "role:Button|name:Load unpacked"
    reload_button: "role:Button|name:Reload"
    extensions_doc: "role:Document|name:Extensions"
    guest_mode_button: "role:Button|name:Guest mode"
    folder_field: "role:Edit|name:Folder:"
    select_folder_btn: "role:Button|name:Select Folder"

  steps:
    # Step 1: Download ZIP with retry mechanism
    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const fs = require('fs');
          const path = require('path');
          const os = require('os');
          (async () => {
            const url = "${{release_url}}";
            if (!url || !url.trim()) throw new Error('release_url is empty');
            
            const tmp = (process.env.TEMP || os.tmpdir());
            const zipPath = path.join(tmp, 'terminator-browser-extension.zip');
            
            let res;
            let lastErr;
            for (let i = 0; i < 3; i++) {
              try {
                res = await fetch(url, { signal: AbortSignal.timeout(30000) }); 
                if (res.ok) break;
                lastErr = `Download failed: ${res.status}`;
              } catch (e) { 
                lastErr = e.message; 
              }
              await sleep(2000);
            }
            
            if (!res || !res.ok) {
              throw new Error(`Download failed after 3 attempts: ${lastErr}`);
            }
            
            const arrayBuf = await res.arrayBuffer();
            fs.writeFileSync(zipPath, Buffer.from(arrayBuf));
            
            console.log(`::set-env name=zip_path::${zipPath}`);
            return { set_env: { zip_path: zipPath } };
          })();

    # Step 2: Extract ZIP using PowerShell
    - tool_name: run_command
      arguments:
        run: |
          $ErrorActionPreference = 'Stop'
          $zip = Join-Path $env:TEMP 'terminator-browser-extension.zip'
          $dest = Join-Path $env:TEMP 'terminator-bridge'
          if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
          New-Item -ItemType Directory -Force -Path $dest | Out-Null
          Expand-Archive -Path $zip -DestinationPath $dest -Force
        shell: powershell

    # Step 3: Find manifest.json folder (handles nested zips)
    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const fs = require('fs');
          const path = require('path');
          const os = require('os');
          (async () => {
            const root = path.join(process.env.TEMP || os.tmpdir(), 'terminator-bridge');
            const stack = [root];
            let picked = null;
            while (stack.length) {
              const dir = stack.pop();
              let entries;
              try { 
                entries = fs.readdirSync(dir, { withFileTypes: true }); 
              } catch (_) { 
                continue; 
              }
              if (entries.some(e => e.isFile && e.name.toLowerCase() === 'manifest.json')) {
                picked = dir; 
                break;
              }
              for (const e of entries) {
                if (e.isDirectory()) {
                  stack.push(path.join(dir, e.name));
                }
              }
            }
            const finalDir = picked || root;
            console.log(`::set-env name=extension_dir_text::${finalDir}`);
            return { set_env: { extension_dir_text: finalDir } };
          })();
      continue_on_error: false

    # Step 4: Navigate to chrome://extensions
    - tool_name: navigate_browser
      arguments:
        url: "chrome://extensions"
        browser: "chrome"
      delay_ms: 1000

    # Step 5: Handle profile selector if present
    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          (async () => {
            let profileWindow;
            try {
              profileWindow = await desktop.locator('role:Window|name:Who\'s using Chrome?').first(250).catch(()=>null);
            } catch(e) { 
              return { profile_handled: false };
            }

            if (!profileWindow) {
              return { profile_handled: false };
            }

            let guestButton;
            try {
              guestButton = await desktop.locator("${{ selectors.guest_mode_button }}").first(1000).catch(()=>null);
              
              if (guestButton) {
                await guestButton.click();
                await sleep(1500);
                return { profile_handled: true };
              }
              return { profile_handled: false };
            } catch (e) {
              return { profile_handled: false };
            }
          })();
      continue_on_error: true

    # Steps 6-9: Navigation fallback
    - tool_name: wait_for_element
      arguments:
        selector: "${{ selectors.address_bar }}"
        condition: "visible"
        timeout_ms: 10000
      continue_on_error: true

    - tool_name: click_element
      arguments:
        selector: "${{ selectors.address_bar }}"
      continue_on_error: true

    - tool_name: type_into_element
      arguments:
        selector: "${{ selectors.address_bar }}"
        text_to_type: "chrome://extensions"
        clear_before_typing: true
        verify_action: false
      continue_on_error: true

    - tool_name: press_key_global
      arguments:
        key: "{Enter}"
      delay_ms: 800
      continue_on_error: true

    # Step 10: Bring Chrome to front
    - tool_name: click_element
      arguments:
        selector: "${{ selectors.extensions_doc }}"
        timeout_ms: 15000
      continue_on_error: false

    # Step 11: Enable Developer mode
    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const toggleSel = "${{ selectors.dev_mode_toggle }}";
          const loadSel = "${{ selectors.load_unpacked }}";

          (async () => {
            let loadVisible = false;
            try {
              await desktop.locator(loadSel).first(500);
              loadVisible = true;
            } catch (_) {
              // Developer mode not enabled
            }
            
            if (!loadVisible) {
              const devToggle = await desktop.locator(toggleSel).first(5000);
              await devToggle.click();
              await sleep(1000);
              await desktop.locator(loadSel).first(5000);
            }
          })();
      continue_on_error: false
      delay_ms: 200

    # Step 12: Remove old Terminator Bridge extension if present
    - tool_name: run_command
      arguments:
        engine: javascript
        run: |
          const extensionName = "Terminator Bridge";

          (async () => {
            try {
              const allElements = await desktop.locator("role:Group").all();
              let terminatorFound = false;
              
              for (let element of allElements) {
                try {
                  const name = await element.name();
                  const text = await element.value();
                  
                  if ((name && name.includes(extensionName)) || (text && text.includes(extensionName))) {
                    terminatorFound = true;
                    const removeButton = await element.locator("role:Button|name:Remove").first();
                    await removeButton.click();
                    await sleep(250);
                    await desktop.press_key("{Enter}");
                    await sleep(500);
                    break;
                  }
                } catch (e) { 
                  continue; 
                }
              }
            } catch (error) {
              // Continue with installation anyway
            }
          })();
      continue_on_error: true
      delay_ms: 500

    # Step 13: Click Load unpacked
    - tool_name: click_element
      arguments:
        selector: "${{ selectors.load_unpacked }}"
      continue_on_error: false
      delay_ms: 300

    # Step 14: Wait for folder dialog
    - tool_name: wait_for_element
      arguments:
        selector: "${{ selectors.folder_field }}"
        condition: "visible"
        timeout_ms: 10000
      continue_on_error: false

    # Step 15: Type folder path
    - tool_name: type_into_element
      arguments:
        selector: "${{ selectors.folder_field }}"
        text_to_type: "${{env.extension_dir_text}}"
        clear_before_typing: true
        verify_action: false
      continue_on_error: false

    # Step 16: Click Select Folder
    - tool_name: click_element
      arguments:
        selector: "${{ selectors.select_folder_btn }}"
      delay_ms: 1200
      continue_on_error: false

    # Step 17: Verify installation
    - tool_name: wait_for_element
      arguments:
        selector: "${{ selectors.reload_button }}"
        condition: "visible"
        timeout_ms: 15000
      continue_on_error: false

  stop_on_error: true
