/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Options for typeText method */
export interface TypeTextOptions {
  /** Whether to use clipboard for pasting. Defaults to false. */
  useClipboard?: boolean
}
/** Result of element validation */
export interface ValidationResult {
  /** Whether the element exists */
  exists: boolean
  /** The element if found */
  element?: Element
  /** Error message if validation failed (not element not found, but actual error) */
  error?: string
}
export interface Bounds {
  x: number
  y: number
  width: number
  height: number
}
export interface Coordinates {
  x: number
  y: number
}
export interface ClickResult {
  method: string
  coordinates?: Coordinates
  details: string
}
export interface CommandOutput {
  exitStatus?: number
  stdout: string
  stderr: string
}
export interface Monitor {
  id: string
  name: string
  isPrimary: boolean
  width: number
  height: number
  x: number
  y: number
  scaleFactor: number
}
export interface MonitorScreenshotPair {
  monitor: Monitor
  screenshot: ScreenshotResult
}
export interface ScreenshotResult {
  width: number
  height: number
  imageData: Array<number>
  monitor?: Monitor
}
export interface UIElementAttributes {
  role: string
  name?: string
  label?: string
  value?: string
  description?: string
  properties: Record<string, string | undefined | null>
  isKeyboardFocusable?: boolean
  bounds?: Bounds
}
export interface UINode {
  id?: string
  attributes: UIElementAttributes
  children: Array<UINode>
}
/** Entry in index-to-bounds mapping for click targeting */
export interface BoundsEntry {
  role: string
  name: string
  bounds: Bounds
  selector?: string
}
/** Result of get_window_tree_result operation with all computed data */
export interface WindowTreeResult {
  /** The raw UI tree structure */
  tree: UINode
  /** Process ID of the window */
  pid: number
  /** Whether this is a browser window */
  isBrowser: boolean
  /** Formatted compact YAML output (if format_output was true) */
  formatted?: string
  /** Mapping of index to bounds for click targeting (keys are 1-based indices as strings) */
  indexToBounds: Record<string, BoundsEntry>
  /** Total count of indexed elements (elements with bounds) */
  elementCount: number
}
export const enum PropertyLoadingMode {
  /** Only load essential properties (role + name) - fastest */
  Fast = 'Fast',
  /** Load all properties for complete element data - slower but comprehensive */
  Complete = 'Complete',
  /** Load specific properties based on element type - balanced approach */
  Smart = 'Smart'
}
/** Output format for UI tree */
export const enum TreeOutputFormat {
  /** Compact YAML format with indexed elements: #1 [ROLE] name */
  CompactYaml = 'CompactYaml',
  /** Full JSON format with all fields and properties */
  VerboseJson = 'VerboseJson',
  /**
   * Clustered YAML format: groups elements from all sources (UIA, DOM, OCR, Omniparser, Gemini)
   * by spatial proximity with prefixed indices (#u1, #d2, #o3, #p4, #g5)
   */
  ClusteredYaml = 'ClusteredYaml'
}
/** Source of an element for clustered output */
export const enum ElementSource {
  /** #u - Accessibility tree (UIA) */
  Uia = 'Uia',
  /** #d - Browser DOM */
  Dom = 'Dom',
  /** #o - OCR text */
  Ocr = 'Ocr',
  /** #p - Omniparser vision */
  Omniparser = 'Omniparser',
  /** #g - Gemini vision */
  Gemini = 'Gemini'
}
/** Display mode for inspect overlay labels */
export const enum OverlayDisplayMode {
  /** Just rectangles, no labels */
  Rectangles = 'Rectangles',
  /** [index] only (default) */
  Index = 'Index',
  /** [role] only */
  Role = 'Role',
  /** [index:role] */
  IndexRole = 'IndexRole',
  /** [name] only */
  Name = 'Name',
  /** [index:name] */
  IndexName = 'IndexName',
  /** [index:role:name] */
  Full = 'Full'
}
/** Element data for inspect overlay rendering */
export interface InspectElement {
  /** 1-based index for click targeting */
  index: number
  /** Element role (e.g., "Button", "Edit") */
  role: string
  /** Element name if available */
  name?: string
  /** Bounding box (x, y, width, height) */
  bounds: Bounds
}
/**
 * OCR element representing text detected via optical character recognition.
 * Hierarchy: OcrResult -> OcrLine -> OcrWord
 */
export interface OcrElement {
  /** Role type: "OcrResult", "OcrLine", or "OcrWord" */
  role: string
  /** The recognized text content */
  text?: string
  /** Bounding box in absolute screen coordinates */
  bounds?: Bounds
  /** Text rotation angle in degrees (only present on OcrResult) */
  textAngle?: number
  /** Confidence score (0.0 to 1.0) if available */
  confidence?: number
  /** Child elements (lines for OcrResult, words for OcrLine) */
  children?: Array<OcrElement>
}
/** Result of OCR operation with tree and index-to-bounds mapping */
export interface OcrResult {
  /** The OCR tree structure */
  tree: OcrElement
  /** Formatted compact YAML output (if format_output was true) */
  formatted?: string
  /**
   * Mapping of index to bounds for click targeting (keys are 1-based indices as strings)
   * Value contains (text, bounds)
   */
  indexToBounds: Record<string, OcrBoundsEntry>
  /** Total count of indexed elements (words with bounds) */
  elementCount: number
}
/** Entry in OCR index-to-bounds mapping for click targeting */
export interface OcrBoundsEntry {
  text: string
  bounds: Bounds
}
/** Browser DOM element captured from a web page */
export interface BrowserDomElement {
  /** HTML tag name (lowercase) */
  tag: string
  /** Element id attribute */
  id?: string
  /** CSS classes */
  classes: Array<string>
  /** Visible text content (truncated to 100 chars) */
  text?: string
  /** href attribute for links */
  href?: string
  /** type attribute for inputs */
  type?: string
  /** name attribute */
  name?: string
  /** value attribute for inputs */
  value?: string
  /** placeholder attribute */
  placeholder?: string
  /** aria-label attribute */
  ariaLabel?: string
  /** role attribute */
  role?: string
  /** Bounding box in screen coordinates */
  bounds: Bounds
}
/** Entry in DOM index-to-bounds mapping for click targeting */
export interface DomBoundsEntry {
  /** Display name (text or aria-label or tag) */
  name: string
  /** HTML tag */
  tag: string
  /** Bounding box */
  bounds: Bounds
}
/** Result of browser DOM capture operation */
export interface BrowserDomResult {
  /** List of captured DOM elements */
  elements: Array<BrowserDomElement>
  /** Formatted compact YAML output (if format_output was true) */
  formatted?: string
  /** Mapping of index to bounds for click targeting */
  indexToBounds: Record<string, DomBoundsEntry>
  /** Total count of captured elements */
  elementCount: number
  /** Page URL */
  pageUrl: string
  /** Page title */
  pageTitle: string
}
/** UI element detected by Gemini vision model */
export interface VisionElement {
  /** Element type: text, icon, button, input, checkbox, dropdown, link, image, unknown */
  elementType: string
  /** Visible text or label on the element */
  content?: string
  /** AI description of what this element is or does */
  description?: string
  /** Bounding box in screen coordinates (x, y, width, height) */
  bounds?: Bounds
  /** Whether the element is interactive/clickable */
  interactivity?: boolean
}
/** Entry in Gemini vision index-to-bounds mapping for click targeting */
export interface VisionBoundsEntry {
  /** Display name (content or description) */
  name: string
  /** Element type */
  elementType: string
  /** Bounding box */
  bounds: Bounds
}
/** Result of Gemini vision detection operation */
export interface GeminiVisionResult {
  /** List of detected UI elements */
  elements: Array<VisionElement>
  /** Formatted compact YAML output (if format_output was true) */
  formatted?: string
  /** Mapping of index to bounds for click targeting */
  indexToBounds: Record<string, VisionBoundsEntry>
  /** Total count of detected elements */
  elementCount: number
}
/** Item detected by Omniparser V2 (icon/field detection) */
export interface OmniparserItem {
  /** Element label: "icon", "text", etc. */
  label: string
  /** Content or OCR text */
  content?: string
  /** Bounding box in screen coordinates (x, y, width, height) */
  bounds?: Bounds
}
/** Entry in Omniparser index-to-bounds mapping for click targeting */
export interface OmniparserBoundsEntry {
  /** Display name (content or label) */
  name: string
  /** Element label */
  label: string
  /** Bounding box */
  bounds: Bounds
}
/** Result of Omniparser detection operation */
export interface OmniparserResult {
  /** List of detected items */
  items: Array<OmniparserItem>
  /** Formatted compact YAML output (if format_output was true) */
  formatted?: string
  /** Mapping of index to bounds for click targeting */
  indexToBounds: Record<string, OmniparserBoundsEntry>
  /** Total count of detected items */
  itemCount: number
}
/** Entry in clustered index mapping (for click targeting across all sources) */
export interface ClusteredBoundsEntry {
  /** Element source (Uia, Dom, Ocr, Omniparser, Gemini) */
  source: ElementSource
  /** Original index within the source */
  originalIndex: number
  /** Bounding box in screen coordinates */
  bounds: Bounds
}
/** Result of clustered tree formatting */
export interface ClusteredFormattingResult {
  /** Formatted clustered YAML output */
  formatted: string
  /** Mapping from prefixed index (e.g., "u1", "d2") to source and bounds */
  indexToSourceAndBounds: Record<string, ClusteredBoundsEntry>
}
export interface TreeBuildConfig {
  /** Property loading strategy */
  propertyMode: PropertyLoadingMode
  /** Optional timeout per operation in milliseconds */
  timeoutPerOperationMs?: number
  /** Optional yield frequency for responsiveness */
  yieldEveryNElements?: number
  /** Optional batch size for processing elements */
  batchSize?: number
  /** Optional maximum depth to traverse (undefined = unlimited) */
  maxDepth?: number
  /** Delay in milliseconds to wait for UI to stabilize before capturing tree */
  uiSettleDelayMs?: number
  /** Generate formatted output alongside the tree structure (defaults to true if tree_output_format is set) */
  formatOutput?: boolean
  /** Output format for tree: 'CompactYaml' (default) or 'VerboseJson' */
  treeOutputFormat?: TreeOutputFormat
  /** Selector to start tree from instead of window root (e.g., "role:Dialog" to focus on a dialog) */
  treeFromSelector?: string
}
export const enum TextPosition {
  Top = 'Top',
  TopRight = 'TopRight',
  Right = 'Right',
  BottomRight = 'BottomRight',
  Bottom = 'Bottom',
  BottomLeft = 'BottomLeft',
  Left = 'Left',
  TopLeft = 'TopLeft',
  Inside = 'Inside'
}
export interface FontStyle {
  size: number
  bold: boolean
  color: number
}
/** A single step in the computer use execution */
export interface ComputerUseStep {
  /** Step number (1-indexed) */
  step: number
  /** Action that was executed */
  action: string
  /** Arguments passed to the action (as JSON string) */
  args: string
  /** Whether the action succeeded */
  success: boolean
  /** Error message if action failed */
  error?: string
  /** Model's reasoning text for this step */
  text?: string
}
/** Pending confirmation info when safety check triggers */
export interface ComputerUsePendingConfirmation {
  /** Action that needs confirmation */
  action: string
  /** Arguments for the action (as JSON string) */
  args: string
  /** Model's explanation text */
  text?: string
}
/** Result of the computer use execution */
export interface ComputerUseResult {
  /** Status: "success", "failed", "needs_confirmation", "max_steps_reached" */
  status: string
  /** The goal that was attempted */
  goal: string
  /** Number of steps executed */
  stepsExecuted: number
  /** Last action performed */
  finalAction: string
  /** Final text response from model */
  finalText?: string
  /** History of all steps */
  steps: Array<ComputerUseStep>
  /** Pending confirmation info if status is "needs_confirmation" */
  pendingConfirmation?: ComputerUsePendingConfirmation
  /** Execution ID for finding screenshots (e.g., "20251205_134500_geminiComputerUse_msedge") */
  executionId?: string
}
/** Information about a window */
export interface WindowInfo {
  /** Window handle */
  hwnd: number
  /** Process name (e.g., "notepad.exe") */
  processName: string
  /** Process ID */
  processId: number
  /** Z-order position (0 = topmost) */
  zOrder: number
  /** Whether the window is minimized */
  isMinimized: boolean
  /** Whether the window is maximized */
  isMaximized: boolean
  /** Whether the window has WS_EX_TOPMOST style */
  isAlwaysOnTop: boolean
  /** Window title */
  title: string
}
/** Main entry point for desktop automation. */
export declare class Desktop {
  /**
   * Create a new Desktop automation instance with configurable options.
   *
   * @param {boolean} [useBackgroundApps=false] - Enable background apps support.
   * @param {boolean} [activateApp=false] - Enable app activation support.
   * @param {string} [logLevel] - Logging level (e.g., 'info', 'debug', 'warn', 'error').
   *                              Falls back to RUST_LOG or TERMINATOR_LOG_LEVEL env vars, defaults to 'info'.
   * @returns {Desktop} A new Desktop automation instance.
   */
  constructor(useBackgroundApps?: boolean | undefined | null, activateApp?: boolean | undefined | null, logLevel?: string | undefined | null)
  /**
   * Get the root UI element of the desktop.
   *
   * @returns {Element} The root UI element.
   */
  root(): Element
  /**
   * Get a list of all running applications.
   *
   * @returns {Array<Element>} List of application UI elements.
   */
  applications(): Array<Element>
  /**
   * Get a running application by name.
   *
   * @param {string} name - The name of the application to find.
   * @returns {Element} The application UI element.
   */
  application(name: string): Element
  /**
   * Open an application by name.
   *
   * @param {string} name - The name of the application to open.
   */
  openApplication(name: string): Element
  /**
   * Activate an application by name.
   *
   * @param {string} name - The name of the application to activate.
   */
  activateApplication(name: string): void
  /**
   * (async) Run a shell command.
   *
   * @param {string} [windowsCommand] - Command to run on Windows.
   * @param {string} [unixCommand] - Command to run on Unix.
   * @returns {Promise<CommandOutput>} The command output.
   */
  runCommand(windowsCommand?: string | undefined | null, unixCommand?: string | undefined | null): Promise<CommandOutput>
  /**
   * (async) Execute a shell command using GitHub Actions-style syntax.
   *
   * @param {string} command - The command to run (can be single or multi-line).
   * @param {string} [shell] - Optional shell to use (defaults to PowerShell on Windows, bash on Unix).
   * @param {string} [workingDirectory] - Optional working directory for the command.
   * @returns {Promise<CommandOutput>} The command output.
   */
  run(command: string, shell?: string | undefined | null, workingDirectory?: string | undefined | null): Promise<CommandOutput>
  /**
   * (async) Perform OCR on an image file.
   *
   * @param {string} imagePath - Path to the image file.
   * @returns {Promise<string>} The extracted text.
   */
  ocrImagePath(imagePath: string): Promise<string>
  /**
   * (async) Perform OCR on a screenshot.
   *
   * @param {ScreenshotResult} screenshot - The screenshot to process.
   * @returns {Promise<string>} The extracted text.
   */
  ocrScreenshot(screenshot: ScreenshotResult): Promise<string>
  /**
   * (async) Perform OCR on a window by PID and return structured results with bounding boxes.
   * Returns an OcrResult containing the OCR tree, formatted output, and index-to-bounds mapping
   * for click targeting.
   *
   * @param {number} pid - Process ID of the target window.
   * @param {boolean} [formatOutput=true] - Whether to generate formatted compact YAML output.
   * @returns {Promise<OcrResult>} Complete OCR result with tree, formatted output, and bounds mapping.
   */
  performOcrForProcess(pid: number, formatOutput?: boolean | undefined | null): Promise<OcrResult>
  /** (async) Perform OCR on a window by PID (non-Windows stub). */
  performOcrForProcess(pid: number, formatOutput?: boolean | undefined | null): Promise<OcrResult>
  /**
   * (async) Capture DOM elements from the current browser tab.
   *
   * Extracts visible DOM elements with their properties and screen coordinates.
   * Uses JavaScript injection via Chrome extension to traverse the DOM tree.
   *
   * @param {number} [maxElements=200] - Maximum number of elements to capture.
   * @param {boolean} [formatOutput=true] - Whether to include formatted compact YAML output.
   * @returns {Promise<BrowserDomResult>} DOM elements with bounds for click targeting.
   */
  captureBrowserDom(maxElements?: number | undefined | null, formatOutput?: boolean | undefined | null): Promise<BrowserDomResult>
  /**
   * (async) Get a clustered tree combining elements from multiple sources grouped by spatial proximity.
   *
   * Combines accessibility tree (UIA) elements with optional DOM and Omniparser elements,
   * clustering nearby elements together. Each element is prefixed with its source:
   * - #u1, #u2... for UIA (accessibility tree)
   * - #d1, #d2... for DOM (browser content)
   * - #p1, #p2... for Omniparser (vision AI detection)
   *
   * @param {number} pid - Process ID of the window to analyze.
   * @param {number} [maxDomElements=100] - Maximum DOM elements to capture for browsers.
   * @param {boolean} [includeOmniparser=false] - Whether to include Omniparser vision detection.
   * @returns {Promise<ClusteredFormattingResult>} Clustered tree with prefixed indices.
   */
  getClusteredTree(pid: number, maxDomElements?: number | undefined | null, includeOmniparser?: boolean | undefined | null): Promise<ClusteredFormattingResult>
  /**
   * (async) Perform Gemini vision AI detection on a window by PID.
   *
   * Captures a screenshot and sends it to the Gemini vision backend for UI element detection.
   * Requires GEMINI_VISION_BACKEND_URL environment variable (defaults to https://app.mediar.ai/api/vision/parse).
   *
   * @param {number} pid - Process ID of the window to capture.
   * @param {boolean} [formatOutput=true] - Whether to include formatted compact YAML output.
   * @returns {Promise<GeminiVisionResult>} Detected UI elements with bounds for click targeting.
   */
  performGeminiVisionForProcess(pid: number, formatOutput?: boolean | undefined | null): Promise<GeminiVisionResult>
  /**
   * (async) Perform Omniparser V2 detection on a window by PID.
   *
   * Captures a screenshot and sends it to the Omniparser backend for icon/field detection.
   * Requires OMNIPARSER_BACKEND_URL environment variable (defaults to https://app.mediar.ai/api/omniparser/parse).
   *
   * @param {number} pid - Process ID of the window to capture.
   * @param {number} [imgsz=1920] - Icon detection image size (640-1920). Higher = better but slower.
   * @param {boolean} [formatOutput=true] - Whether to include formatted compact YAML output.
   * @returns {Promise<OmniparserResult>} Detected items with bounds for click targeting.
   */
  performOmniparserForProcess(pid: number, imgsz?: number | undefined | null, formatOutput?: boolean | undefined | null): Promise<OmniparserResult>
  /**
   * (async) Get the currently focused browser window.
   *
   * @returns {Promise<Element>} The current browser window element.
   */
  getCurrentBrowserWindow(): Promise<Element>
  /**
   * Create a locator for finding UI elements.
   *
   * @param {string | Selector} selector - The selector.
   * @returns {Locator} A locator for finding elements.
   */
  locator(selector: string | Selector): Locator
  /**
   * (async) Get the currently focused window.
   *
   * @returns {Promise<Element>} The current window element.
   */
  getCurrentWindow(): Promise<Element>
  /**
   * (async) Get the currently focused application.
   *
   * @returns {Promise<Element>} The current application element.
   */
  getCurrentApplication(): Promise<Element>
  /**
   * Get the currently focused element.
   *
   * @returns {Element} The focused element.
   */
  focusedElement(): Element
  /**
   * Open a URL in a browser.
   *
   * @param {string} url - The URL to open.
   * @param {string} [browser] - The browser to use. Can be "Default", "Chrome", "Firefox", "Edge", "Brave", "Opera", "Vivaldi", or a custom browser path.
   */
  openUrl(url: string, browser?: string | undefined | null): Element
  /**
   * Open a file with its default application.
   *
   * @param {string} filePath - Path to the file to open.
   */
  openFile(filePath: string): void
  /**
   * Activate a browser window by title.
   *
   * @param {string} title - The window title to match.
   */
  activateBrowserWindowByTitle(title: string): void
  /**
   * Get the UI tree for a window identified by process ID and optional title.
   *
   * @param {number} pid - Process ID of the target application.
   * @param {string} [title] - Optional window title filter.
   * @param {TreeBuildConfig} [config] - Optional configuration for tree building.
   * @returns {UINode} Complete UI tree starting from the identified window.
   */
  getWindowTree(pid: number, title?: string | undefined | null, config?: TreeBuildConfig | undefined | null): UINode
  /**
   * Get the UI tree with full result including formatting and bounds mapping.
   *
   * This is the recommended method for getting window trees when you need:
   * - Formatted YAML output for LLM consumption
   * - Index-to-bounds mapping for click targeting
   * - Browser detection
   *
   * @param {number} pid - Process ID of the target application.
   * @param {string} [title] - Optional window title filter.
   * @param {TreeBuildConfig} [config] - Configuration options:
   *   - formatOutput: Enable formatted output (default: true if treeOutputFormat set)
   *   - treeOutputFormat: 'CompactYaml' (default) or 'VerboseJson'
   *   - treeFromSelector: Selector to start tree from (use getWindowTreeResultAsync for this)
   * @returns {WindowTreeResult} Complete result with tree, formatted output, and bounds mapping.
   */
  getWindowTreeResult(pid: number, title?: string | undefined | null, config?: TreeBuildConfig | undefined | null): WindowTreeResult
  /**
   * (async) Get the UI tree with full result, supporting tree_from_selector.
   *
   * Use this method when you need to scope the tree to a specific subtree using a selector.
   *
   * @param {number} pid - Process ID of the target application.
   * @param {string} [title] - Optional window title filter.
   * @param {TreeBuildConfig} [config] - Configuration options:
   *   - formatOutput: Enable formatted output (default: true)
   *   - treeOutputFormat: 'CompactYaml' (default) or 'VerboseJson'
   *   - treeFromSelector: Selector to start tree from (e.g., "role:Dialog")
   * @returns {Promise<WindowTreeResult>} Complete result with tree, formatted output, and bounds mapping.
   */
  getWindowTreeResultAsync(pid: number, title?: string | undefined | null, config?: TreeBuildConfig | undefined | null): Promise<WindowTreeResult>
  /**
   * (async) List all available monitors/displays.
   *
   * @returns {Promise<Array<Monitor>>} List of monitor information.
   */
  listMonitors(): Promise<Array<Monitor>>
  /**
   * (async) Get the primary monitor.
   *
   * @returns {Promise<Monitor>} Primary monitor information.
   */
  getPrimaryMonitor(): Promise<Monitor>
  /**
   * (async) Get the monitor containing the currently focused window.
   *
   * @returns {Promise<Monitor>} Active monitor information.
   */
  getActiveMonitor(): Promise<Monitor>
  /**
   * (async) Get a monitor by its ID.
   *
   * @param {string} id - The monitor ID to find.
   * @returns {Promise<Monitor>} Monitor information.
   */
  getMonitorById(id: string): Promise<Monitor>
  /**
   * (async) Get a monitor by its name.
   *
   * @param {string} name - The monitor name to find.
   * @returns {Promise<Monitor>} Monitor information.
   */
  getMonitorByName(name: string): Promise<Monitor>
  /**
   * (async) Capture a screenshot of a specific monitor.
   *
   * @param {Monitor} monitor - The monitor to capture.
   * @returns {Promise<ScreenshotResult>} The screenshot data.
   */
  captureMonitor(monitor: Monitor): Promise<ScreenshotResult>
  /**
   * (async) Capture screenshots of all monitors.
   *
   * @returns {Promise<Array<{monitor: Monitor, screenshot: ScreenshotResult}>>} Array of monitor and screenshot pairs.
   */
  captureAllMonitors(): Promise<Array<MonitorScreenshotPair>>
  /**
   * (async) Get all window elements for a given application name.
   *
   * @param {string} name - The name of the application whose windows will be retrieved.
   * @returns {Promise<Array<Element>>} A list of window elements belonging to the application.
   */
  windowsForApplication(name: string): Promise<Array<Element>>
  /**
   * (async) Get the UI tree for all open applications in parallel.
   *
   * @returns {Promise<Array<UINode>>} List of UI trees for all applications.
   */
  getAllApplicationsTree(): Promise<Array<UINode>>
  /**
   * (async) Press a key globally.
   *
   * @param {string} key - The key to press (e.g., "Enter", "Ctrl+C", "F1").
   */
  pressKey(key: string): Promise<void>
  /**
   * (async) Execute JavaScript in the currently focused browser tab.
   * Automatically finds the active browser window and executes the script.
   *
   * @param {string} script - The JavaScript code to execute in browser context.
   * @returns {Promise<string>} The result of script execution.
   */
  executeBrowserScript(script: string): Promise<string>
  /**
   * (async) Delay execution for a specified number of milliseconds.
   * Useful for waiting between actions to ensure UI stability.
   *
   * @param {number} delayMs - Delay in milliseconds.
   * @returns {Promise<void>}
   */
  delay(delayMs: number): Promise<void>
  /**
   * Navigate to a URL in a browser.
   * This is the recommended method for browser navigation - more reliable than
   * manually manipulating the address bar with keyboard/mouse actions.
   *
   * @param {string} url - URL to navigate to
   * @param {string | null} browser - Optional browser name ('Chrome', 'Firefox', 'Edge', 'Brave', 'Opera', 'Vivaldi', or 'Default')
   * @returns {Promise<Element>} The browser window element
   */
  navigateBrowser(url: string, browser?: string | undefined | null): Element
  /**
   * (async) Set the zoom level to a specific percentage.
   *
   * @param {number} percentage - The zoom percentage (e.g., 100 for 100%, 150 for 150%, 50 for 50%).
   */
  setZoom(percentage: number): Promise<void>
  /**
   * (async) Run Gemini Computer Use agentic loop.
   *
   * Provide a goal and target process, and this will autonomously take actions
   * (click, type, scroll, etc.) until the goal is achieved or max_steps is reached.
   * Uses Gemini's vision model to analyze screenshots and decide actions.
   *
   * @param {string} process - Process name of the target application (e.g., "chrome", "notepad")
   * @param {string} goal - What to achieve (e.g., "Open Notepad and type Hello World")
   * @param {number} [maxSteps=20] - Maximum number of steps before stopping
   * @param {function} [onStep] - Optional callback invoked after each step with step details
   * @returns {Promise<ComputerUseResult>} Result with status, steps executed, and history
   */
  geminiComputerUse(process: string, goal: string, maxSteps?: number | undefined | null, onStep?: ((err: null | Error, step: ComputerUseStep) => void) | undefined): Promise<ComputerUseResult>
  /**
   * Stop all currently executing operations.
   *
   * This cancels the internal cancellation token, which will cause any
   * operations that check `isCancelled()` to abort. After calling this,
   * you should create a new Desktop instance to start fresh.
   */
  stopExecution(): void
  /**
   * Check if execution has been cancelled.
   *
   * Returns `true` if `stopExecution()` has been called.
   * Long-running operations should periodically check this and abort if true.
   */
  isCancelled(): boolean
  /**
   * Stop all active highlight overlays globally.
   *
   * This finds and destroys all highlight overlay windows that were created
   * by `element.highlight()`. Useful for cleaning up highlights without
   * needing to track individual HighlightHandle objects.
   *
   * @returns {number} The number of highlights that were stopped.
   */
  stopHighlighting(): number
  /**
   * Show inspect overlay with indexed elements for visual debugging.
   *
   * Displays a transparent overlay window with colored rectangles around UI elements,
   * showing their index numbers for click targeting. Use `hideInspectOverlay()` to remove.
   *
   * @param {InspectElement[]} elements - Array of elements to highlight with their bounds.
   * @param {object} windowBounds - The window bounds {x, y, width, height} to constrain the overlay.
   * @param {OverlayDisplayMode} [displayMode='Index'] - What to show in labels: 'Index', 'Role', 'Name', etc.
   */
  showInspectOverlay(elements: Array<InspectElement>, windowBounds: Bounds, displayMode?: OverlayDisplayMode | undefined | null): void
  /** Show inspect overlay (non-Windows stub). */
  showInspectOverlay(elements: Array<InspectElement>, windowBounds: Bounds, displayMode?: OverlayDisplayMode | undefined | null): void
  /**
   * Hide any active inspect overlay.
   *
   * This hides the visual overlay that was shown via `showInspectOverlay()`.
   * Can be called from any thread.
   */
  hideInspectOverlay(): void
}
/** A UI element in the accessibility tree. */
export declare class Element {
  /**
   * Get the element's ID.
   *
   * @returns {string | null} The element's ID, if available.
   */
  id(): string | null
  /**
   * Get the element's role.
   *
   * @returns {string} The element's role (e.g., "button", "textfield").
   */
  role(): string
  /**
   * Get all attributes of the element.
   *
   * @returns {UIElementAttributes} The element's attributes.
   */
  attributes(): UIElementAttributes
  /**
   * Get the element's name.
   *
   * @returns {string | null} The element's name, if available.
   */
  name(): string | null
  /**
   * Get children of this element.
   *
   * @returns {Array<Element>} List of child elements.
   */
  children(): Array<Element>
  /**
   * Get the parent element.
   *
   * @returns {Element | null} The parent element, if available.
   */
  parent(): Element | null
  /**
   * Get element bounds.
   *
   * @returns {Bounds} The element's bounds (x, y, width, height).
   */
  bounds(): Bounds
  /**
   * Click on this element.
   *
   * @returns {ClickResult} Result of the click operation.
   */
  click(): ClickResult
  /**
   * Double click on this element.
   *
   * @returns {ClickResult} Result of the click operation.
   */
  doubleClick(): ClickResult
  /** Right click on this element. */
  rightClick(): void
  /** Hover over this element. */
  hover(): void
  /**
   * Check if element is visible.
   *
   * @returns {boolean} True if the element is visible.
   */
  isVisible(): boolean
  /**
   * Check if element is enabled.
   *
   * @returns {boolean} True if the element is enabled.
   */
  isEnabled(): boolean
  /** Focus this element. */
  focus(): void
  /**
   * Get text content of this element.
   *
   * @param {number} [maxDepth] - Maximum depth to search for text.
   * @returns {string} The element's text content.
   */
  text(maxDepth?: number | undefined | null): string
  /**
   * Type text into this element.
   *
   * @param {string} text - The text to type.
   * @param {TypeTextOptions} [options] - Options for typing.
   */
  typeText(text: string, options?: TypeTextOptions | undefined | null): void
  /**
   * Press a key while this element is focused.
   *
   * @param {string} key - The key to press.
   */
  pressKey(key: string): void
  /**
   * Set value of this element.
   *
   * @param {string} value - The value to set.
   */
  setValue(value: string): void
  /**
   * Perform a named action on this element.
   *
   * @param {string} action - The action to perform.
   */
  performAction(action: string): void
  /**
   * Invoke this element (triggers the default action).
   * This is often more reliable than clicking for controls like radio buttons or menu items.
   */
  invoke(): void
  /**
   * Scroll the element in a given direction.
   *
   * @param {string} direction - The direction to scroll.
   * @param {number} amount - The amount to scroll.
   */
  scroll(direction: string, amount: number): void
  /** Activate the window containing this element. */
  activateWindow(): void
  /** Minimize the window containing this element. */
  minimizeWindow(): void
  /** Maximize the window containing this element. */
  maximizeWindow(): void
  /**
   * Check if element is focused.
   *
   * @returns {boolean} True if the element is focused.
   */
  isFocused(): boolean
  /**
   * Check if element is keyboard focusable.
   *
   * @returns {boolean} True if the element can receive keyboard focus.
   */
  isKeyboardFocusable(): boolean
  /**
   * Drag mouse from start to end coordinates.
   *
   * @param {number} startX - Starting X coordinate.
   * @param {number} startY - Starting Y coordinate.
   * @param {number} endX - Ending X coordinate.
   * @param {number} endY - Ending Y coordinate.
   */
  mouseDrag(startX: number, startY: number, endX: number, endY: number): void
  /**
   * Press and hold mouse at coordinates.
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   */
  mouseClickAndHold(x: number, y: number): void
  /**
   * Move mouse to coordinates.
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   */
  mouseMove(x: number, y: number): void
  /** Release mouse button. */
  mouseRelease(): void
  /**
   * Create a locator from this element.
   * Accepts either a selector string or a Selector object.
   *
   * @param {string | Selector} selector - The selector.
   * @returns {Locator} A new locator for finding elements.
   */
  locator(selector: string | Selector): Locator
  /**
   * Get the containing application element.
   *
   * @returns {Element | null} The containing application element, if available.
   */
  application(): Element | null
  /**
   * Get the containing window element.
   *
   * @returns {Element | null} The containing window element, if available.
   */
  window(): Element | null
  /**
   * Highlights the element with a colored border and optional text overlay.
   *
   * @param {number} [color] - Optional BGR color code (32-bit integer). Default: 0x0000FF (red)
   * @param {number} [durationMs] - Optional duration in milliseconds.
   * @param {string} [text] - Optional text to display. Text will be truncated to 10 characters.
   * @param {TextPosition} [textPosition] - Optional position for the text overlay (default: Top)
   * @param {FontStyle} [fontStyle] - Optional font styling for the text
   * @returns {HighlightHandle} Handle that can be used to close the highlight early
   */
  highlight(color?: number | undefined | null, durationMs?: number | undefined | null, text?: string | undefined | null, textPosition?: TextPosition | undefined | null, fontStyle?: FontStyle | undefined | null): HighlightHandle
  /**
   * Capture a screenshot of this element.
   *
   * @returns {ScreenshotResult} The screenshot data containing image data and dimensions.
   */
  capture(): ScreenshotResult
  /**
   * Get the process ID of the application containing this element.
   *
   * @returns {number} The process ID.
   */
  processId(): number
  /**
   * Get the process name of the application containing this element.
   *
   * @returns {string} The process name (e.g., "chrome", "notepad").
   */
  processName(): string
  toString(): string
  /**
   * Sets the transparency of the window.
   *
   * @param {number} percentage - The transparency percentage from 0 (completely transparent) to 100 (completely opaque).
   * @returns {void}
   */
  setTransparency(percentage: number): void
  /**
   * Close the element if it's closable (like windows, applications).
   * Does nothing for non-closable elements (like buttons, text, etc.).
   *
   * @returns {void}
   */
  close(): void
  /**
   * Get the monitor containing this element.
   *
   * @returns {Monitor} The monitor information for the display containing this element.
   */
  monitor(): Monitor
  /**
   * Scrolls the element into view within its window viewport.
   * If the element is already visible, returns immediately.
   *
   * @returns {void}
   */
  scrollIntoView(): void
  /**
   * Selects an option in a dropdown or combobox by its visible text.
   *
   * @param {string} optionName - The visible text of the option to select.
   * @returns {void}
   */
  selectOption(optionName: string): void
  /**
   * Lists all available option strings from a dropdown or list box.
   *
   * @returns {Array<string>} List of available option strings.
   */
  listOptions(): Array<string>
  /**
   * Checks if a control (like a checkbox or toggle switch) is currently toggled on.
   *
   * @returns {boolean} True if the control is toggled on.
   */
  isToggled(): boolean
  /**
   * Sets the state of a toggleable control.
   * It only performs an action if the control is not already in the desired state.
   *
   * @param {boolean} state - The desired toggle state.
   * @returns {void}
   */
  setToggled(state: boolean): void
  /**
   * Checks if an element is selected (e.g., list item, tree node, tab).
   *
   * @returns {boolean} True if the element is selected, false otherwise.
   */
  isSelected(): boolean
  /**
   * Sets the selection state of a selectable item.
   * Only performs an action if the element is not already in the desired state.
   *
   * @param {boolean} state - The desired selection state.
   * @returns {void}
   */
  setSelected(state: boolean): void
  /**
   * Gets the current value from a range-based control like a slider or progress bar.
   *
   * @returns {number} The current value of the range control.
   */
  getRangeValue(): number
  /**
   * Sets the value of a range-based control like a slider.
   *
   * @param {number} value - The value to set.
   * @returns {void}
   */
  setRangeValue(value: number): void
  /**
   * Gets the value attribute of an element (text inputs, combo boxes, etc.).
   *
   * @returns {string | null} The value attribute, or null if not available.
   */
  getValue(): string | null
  /**
   * Execute JavaScript in web browser using dev tools console.
   * Returns the result of the script execution as a string.
   *
   * @param {string} script - The JavaScript code to execute.
   * @returns {Promise<string>} The result of script execution.
   */
  executeBrowserScript(script: string): Promise<string>
  /**
   * Get the UI tree starting from this element.
   * Returns a tree structure containing this element and all its descendants.
   *
   * @param {number} [maxDepth=100] - Maximum depth to traverse (default: 100).
   * @returns {UINode} Tree structure with recursive children.
   */
  getTree(maxDepth?: number | undefined | null): UINode
}
/** Locator for finding UI elements by selector. */
export declare class Locator {
  /**
   * (async) Get the first matching element.
   *
   * @param {number} timeoutMs - Timeout in milliseconds (required).
   * @returns {Promise<Element>} The first matching element.
   */
  first(timeoutMs: number): Promise<Element>
  /**
   * (async) Get all matching elements.
   *
   * @param {number} timeoutMs - Timeout in milliseconds (required).
   * @param {number} [depth] - Maximum depth to search.
   * @returns {Promise<Array<Element>>} List of matching elements.
   */
  all(timeoutMs: number, depth?: number | undefined | null): Promise<Array<Element>>
  /**
   * Set a default timeout for this locator.
   *
   * @param {number} timeoutMs - Timeout in milliseconds.
   * @returns {Locator} A new locator with the specified timeout.
   */
  timeout(timeoutMs: number): Locator
  /**
   * Set the root element for this locator.
   *
   * @param {Element} element - The root element.
   * @returns {Locator} A new locator with the specified root element.
   */
  within(element: Element): Locator
  /**
   * Chain another selector.
   * Accepts either a selector string or a Selector object.
   *
   * @param {string | Selector} selector - The selector.
   * @returns {Locator} A new locator with the chained selector.
   */
  locator(selector: string | Selector): Locator
  /**
   * (async) Validate element existence without throwing an error.
   *
   * @param {number} timeoutMs - Timeout in milliseconds (required).
   * @returns {Promise<ValidationResult>} Validation result with exists flag and optional element.
   */
  validate(timeoutMs: number): Promise<ValidationResult>
  /**
   * (async) Wait for an element to meet a specific condition.
   *
   * @param {string} condition - Condition to wait for: 'exists', 'visible', 'enabled', 'focused'
   * @param {number} timeoutMs - Timeout in milliseconds (required).
   * @returns {Promise<Element>} The element when condition is met.
   */
  waitFor(condition: string, timeoutMs: number): Promise<Element>
}
/** Selector for locating UI elements. Provides a typed alternative to the string based selector API. */
export declare class Selector {
  /** Create a selector that matches elements by their accessibility `name`. */
  static name(name: string): Selector
  /** Create a selector that matches elements by role (and optionally name). */
  static role(role: string, name?: string | undefined | null): Selector
  /** Create a selector that matches elements by accessibility `id`. */
  static id(id: string): Selector
  /** Create a selector that matches elements by the text they display. */
  static text(text: string): Selector
  /** Create a selector from an XPath-like path string. */
  static path(path: string): Selector
  /** Create a selector that matches elements by a native automation id (e.g., AutomationID on Windows). */
  static nativeId(id: string): Selector
  /** Create a selector that matches elements by their class name. */
  static className(name: string): Selector
  /** Create a selector from an arbitrary attribute map. */
  static attributes(attributes: Record<string, string>): Selector
  /** Chain another selector onto this selector. */
  chain(other: Selector): Selector
  /** Filter by visibility. */
  visible(isVisible: boolean): Selector
  /**
   * Create a selector that selects the nth element from matches.
   * Positive values are 0-based from the start (0 = first, 1 = second).
   * Negative values are from the end (-1 = last, -2 = second-to-last).
   */
  static nth(index: number): Selector
  /**
   * Create a selector that matches elements having at least one descendant matching the inner selector.
   * This is similar to Playwright's :has() pseudo-class.
   */
  static has(innerSelector: Selector): Selector
  /**
   * Create a selector that navigates to the parent element.
   * This is similar to Playwright's .. syntax.
   */
  static parent(): Selector
}
export declare class HighlightHandle {
  close(): void
}
/**
 * Window manager for controlling window states
 *
 * Provides functionality for:
 * - Enumerating windows with Z-order tracking
 * - Bringing windows to front (bypassing Windows focus-stealing prevention)
 * - Minimizing/maximizing windows
 * - Capturing and restoring window states for workflows
 */
export declare class WindowManager {
  /** Create a new WindowManager instance */
  constructor()
  /** Update window cache with current window information */
  updateWindowCache(): Promise<void>
  /** Get topmost window for a process by name */
  getTopmostWindowForProcess(process: string): Promise<WindowInfo | null>
  /** Get topmost window for a specific PID */
  getTopmostWindowForPid(pid: number): Promise<WindowInfo | null>
  /** Get all visible always-on-top windows */
  getAlwaysOnTopWindows(): Promise<Array<WindowInfo>>
  /**
   * Minimize only always-on-top windows (excluding target)
   * Returns the number of windows minimized
   */
  minimizeAlwaysOnTopWindows(targetHwnd: number): Promise<number>
  /** Minimize all visible windows except the target */
  minimizeAllExcept(targetHwnd: number): Promise<number>
  /**
   * Maximize window if not already maximized
   * Returns true if the window was maximized (wasn't already maximized)
   */
  maximizeIfNeeded(hwnd: number): Promise<boolean>
  /**
   * Bring window to front using AttachThreadInput trick
   *
   * This uses AttachThreadInput to bypass Windows' focus-stealing prevention.
   * Returns true if the window is now in the foreground.
   */
  bringWindowToFront(hwnd: number): Promise<boolean>
  /**
   * Minimize window if not already minimized
   * Returns true if the window was minimized (wasn't already minimized)
   */
  minimizeIfNeeded(hwnd: number): Promise<boolean>
  /** Capture current state before workflow */
  captureInitialState(): Promise<void>
  /**
   * Restore windows that were minimized and target window to their original state
   * Returns the number of windows restored
   */
  restoreAllWindows(): Promise<number>
  /** Clear captured state */
  clearCapturedState(): Promise<void>
  /** Check if a process is a UWP/Modern app */
  isUwpApp(pid: number): Promise<boolean>
  /** Track a window as the target for restoration */
  setTargetWindow(hwnd: number): Promise<void>
}
