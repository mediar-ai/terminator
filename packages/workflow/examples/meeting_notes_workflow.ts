/**
 * Meeting Notes Generator Workflow
 * 
 * A practical workflow example that demonstrates:
 * - Multi-step automation
 * - Context sharing between steps
 * - Error recovery
 * - Type safety with Zod schemas
 * 
 * This workflow automates creating structured meeting notes in Notepad
 * and saving the file.
 * 
 * NOTE: This example is Windows-only.
 * 
 * PREREQUISITES:
 * -------------
 * From the workflow package directory:
 * npm install
 * 
 * USAGE:
 * ------
 * From the workflow package directory:
 * npx ts-node examples/meeting_notes_workflow.ts
 * 
 * Or compile first:
 *   tsc examples/meeting_notes_workflow.ts
 *   node examples/meeting_notes_workflow.js
 */

import { Desktop } from '@mediar-ai/terminator';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { z } from 'zod';
import { createStep } from '../src/step';
import type {
    ErrorContext,
    StepContext,
    WorkflowErrorContext,
    WorkflowSuccessContext
} from '../src/types';
import { createWorkflow } from '../src/workflow';

// Detect Windows 11 (build number >= 22000)
function isWindows11(): boolean {
    if (process.platform !== 'win32') {
        return false;
    }
    const release = os.release();
    // os.release() on Windows returns something like "10.0.22000"
    // Windows 11 has build number >= 22000
    const parts = release.split('.');
    if (parts.length >= 3) {
        const buildNumber = parseInt(parts[2], 10);
        return !isNaN(buildNumber) && buildNumber >= 22000;
    }
    return false;
}

// Type assertion helper - createWorkflow returns WorkflowBuilder when no steps provided
type BuilderResult<T> = ReturnType<typeof createWorkflow<T>> & {
    step: <TOutput = any>(step: any) => BuilderResult<T>;
    onSuccess: (handler: any) => BuilderResult<T>;
    onError: (handler: any) => BuilderResult<T>;
    build: () => any;
};

// Define input schema with validation
const InputSchema = z.object({
    meetingTitle: z.string().describe('Title of the meeting'),
    attendees: z.array(z.string()).default([]).describe('List of attendee names'),
    agenda: z.array(z.string()).default([]).describe('Agenda items'),
    notes: z.array(z.string()).default([]).describe('Meeting notes/discussion points'),
    actionItems: z.array(z.object({
        task: z.string(),
        assignee: z.string(),
        dueDate: z.string().optional(),
    })).default([]).describe('Action items with assignees'),
    includeTimestamp: z.boolean().default(true).describe('Include timestamp in notes'),
    outputDirectory: z.string().optional().describe('Directory to save the file (defaults to home directory)'),
    useClipboard: z.boolean().default(true).describe('Use clipboard for faster text input (recommended for large text blocks)'),
});

type WorkflowInput = z.infer<typeof InputSchema>;

// Format date and time
function getFormattedTimestamp(): string {
    const now = new Date();
    return now.toLocaleString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    });
}

// Generate formatted meeting notes text
function generateMeetingNotes(input: WorkflowInput): string {
    const lines: string[] = [];

    lines.push('='.repeat(60));
    lines.push(`MEETING NOTES: ${input.meetingTitle}`);
    lines.push('='.repeat(60));
    lines.push('');

    if (input.includeTimestamp) {
        lines.push(`Date & Time: ${getFormattedTimestamp()}`);
        lines.push('');
    }

    if (input.attendees.length > 0) {
        lines.push('Attendees:');
        input.attendees.forEach((attendee: string, idx: number) => {
            lines.push(`  ${idx + 1}. ${attendee}`);
        });
        lines.push('');
    }

    if (input.agenda.length > 0) {
        lines.push('Agenda:');
        input.agenda.forEach((item: string, idx: number) => {
            lines.push(`  ${idx + 1}. ${item}`);
        });
        lines.push('');
    }

    if (input.notes.length > 0) {
        lines.push('Notes & Discussion:');
        input.notes.forEach((note: string, idx: number) => {
            lines.push(`  ${idx + 1}. ${note}`);
        });
        lines.push('');
    }

    if (input.actionItems.length > 0) {
        lines.push('Action Items:');
        input.actionItems.forEach((item: { task: string; assignee: string; dueDate?: string }, idx: number) => {
            const dueDate = item.dueDate ? ` (Due: ${item.dueDate})` : '';
            lines.push(`  ${idx + 1}. ${item.task}`);
            lines.push(`     Assigned to: ${item.assignee}${dueDate}`);
        });
        lines.push('');
    }

    lines.push('='.repeat(60));
    lines.push(`Generated by Terminator Workflow`);
    lines.push('='.repeat(60));

    return lines.join('\n');
}

// Step 1: Open Notepad
const openEditor = createStep<WorkflowInput>({
    id: 'open-editor',
    name: 'Open Notepad',
    description: 'Opens Notepad on Windows',
    execute: async ({ desktop, logger, context }: StepContext<WorkflowInput>) => {
        logger.info('Opening Notepad...');

        const editor = desktop.openApplication('notepad.exe');

        // Store window reference in context for later steps
        context.data.editorWindow = editor;

        logger.success(`‚úÖ Notepad opened successfully`);
    },
    onError: async ({ error, retry, attempt, logger }: ErrorContext<WorkflowInput>) => {
        logger.warn(`‚ö†Ô∏è  Failed to open editor (attempt ${attempt + 1})`);

        // Retry once with a longer wait time
        if (attempt === 0) {
            logger.info('üîÑ Retrying with longer wait time...');
            await new Promise(resolve => setTimeout(resolve, 3000));
            return retry();
        }

        return { recoverable: false, reason: 'Failed to open editor after retries' };
    },
});

// Step 2: Type the meeting notes
const typeNotes = createStep<WorkflowInput>({
    id: 'type-notes',
    name: 'Type Meeting Notes',
    description: 'Types the formatted meeting notes into Notepad',
    execute: async ({ desktop, input, logger, context }: StepContext<WorkflowInput>) => {
        logger.info('Generating and typing meeting notes...');

        const notesText = generateMeetingNotes(input);

        // Get the editor window from context
        const editor = context.data.editorWindow;

        // Handle Windows 11 vs Windows 10 Notepad differences (matching notepad.py logic)
        // Windows 11 requires clicking "Add New Tab" first
        let document;
        if (isWindows11()) {
            // Windows 11: Click "Add New Tab" button first
            const addButton = await editor.locator('name:Add New Tab').first(5000);
            addButton.click();
            await desktop.delay(500);
            document = await editor.locator('role:Document').first(5000);
        } else {
            // Windows 10: Use direct Edit locator
            document = await editor.locator('role:Edit').first(5000);
        }

        // Type the notes (using clipboard if enabled)
        document.typeText(notesText, input.useClipboard);
        await desktop.delay(500);

        logger.success(`‚úÖ Typed ${notesText.split('\n').length} lines of meeting notes`);

        // Store document reference and notes text in context for later steps
        context.data.document = document;
        context.data.notesText = notesText;
    },
    onError: async ({ error, retry, attempt, logger }: ErrorContext<WorkflowInput>) => {
        if (attempt < 2) {
            logger.info(`üîÑ Retrying typing notes (attempt ${attempt + 1})...`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            return retry();
        }
        return { recoverable: false, reason: 'Failed to type notes after retries' };
    },
});

// Step 3: Save the file
const saveFile = createStep<WorkflowInput>({
    id: 'save-file',
    name: 'Save Meeting Notes',
    description: 'Saves the meeting notes to a file',
    execute: async ({ desktop, input, logger, context }: StepContext<WorkflowInput>) => {
        logger.info('Opening Save dialog...');

        const document = context.data.document;

        // Open save dialog - press Ctrl+S on the document (matching notepad.py)
        document.pressKey('{Ctrl}s');
        await desktop.delay(1500);

        // Determine file path (using os.homedir() - TypeScript equivalent of os.path.expanduser("~"))
        const outputDir = input.outputDirectory || os.homedir();
        const safeTitle = input.meetingTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const timestamp = new Date().toISOString().split('T')[0];
        const fileName = `meeting_notes_${safeTitle}_${timestamp}.txt`;
        const filePath = path.join(outputDir, fileName);

        logger.info(`Saving to: ${filePath}`);

        // Find and fill the file name field in save dialog (matching notepad.py pattern)
        const editor = context.data.editorWindow;
        const saveDialog = editor.locator('window:Save As');
        await desktop.delay(1000); // Wait for dialog to appear

        const fileInput = await saveDialog
            .locator('role:Pane')
            .locator('role:ComboBox')
            .locator('role:Edit')
            .first(5000);

        // Type file path (using clipboard if enabled)
        fileInput.typeText(filePath, input.useClipboard);
        await desktop.delay(500);

        // Check if file already exists
        const fileAlreadyExists = fs.existsSync(filePath);

        // Click Save button
        const saveButton = await saveDialog.locator('Button:Save').first(5000);
        saveButton.click();
        await desktop.delay(1000);

        // Handle overwrite confirmation if needed (matching notepad.py pattern)
        if (fileAlreadyExists) {
            try {
                const confirmDialog = saveDialog.locator('Window:Confirm Save As');
                const yesButton = await confirmDialog.locator('Name:Yes').first(2000);
                yesButton.click();
                await desktop.delay(500);
                logger.info('Confirmed overwrite');
            } catch {
                // No confirmation dialog
            }
        }

        logger.success(`‚úÖ File saved successfully: ${fileName}`);

        // Store file path in context for next steps
        context.data.filePath = filePath;
        context.data.fileName = fileName;
    },
});

// Create the workflow
// TypeScript needs help: createWorkflow returns WorkflowBuilder | Workflow
// Since we're not providing steps in config, we know it returns WorkflowBuilder
const meetingNotesWorkflow = (
    createWorkflow({
        name: 'Meeting Notes Generator',
        description: 'Automates creating structured meeting notes in Notepad on Windows',
        version: '1.0.0',
        input: InputSchema,
    }) as BuilderResult<WorkflowInput>
)
    .step(openEditor)
    .step(typeNotes)
    .step(saveFile)
    .onSuccess(async ({ logger, context, duration }: WorkflowSuccessContext<WorkflowInput>) => {
        logger.info('');
        logger.success('üìù Meeting notes workflow completed successfully!');
        logger.info(`   File saved: ${context.data.fileName || 'Unknown'}`);
        logger.info(`   Duration: ${duration}ms`);
    })
    .onError(async ({ error, step, logger }: WorkflowErrorContext<WorkflowInput>) => {
        logger.error(`‚ùå Workflow failed at step: ${step.config.name}`);
        logger.error(`   Error: ${error.message}`);
    })
    .build();

// Example usage
async function main() {
    const desktop = new Desktop(false, false, 'error');

    // Example input
    const input: WorkflowInput = {
        meetingTitle: 'Q4 Product Planning',
        attendees: ['Alice', 'Bob', 'Charlie'],
        agenda: [
            'Review Q3 results',
            'Plan Q4 features',
            'Discuss resource allocation',
        ],
        notes: [
            'Q3 revenue exceeded targets by 15%',
            'Team decided to prioritize mobile app improvements',
            'Need to hire 2 additional engineers',
        ],
        actionItems: [
            {
                task: 'Create feature spec document',
                assignee: 'Alice',
                dueDate: '2024-12-15',
            },
            {
                task: 'Post job openings',
                assignee: 'Bob',
                dueDate: '2024-12-10',
            },
            {
                task: 'Schedule follow-up meeting',
                assignee: 'Charlie',
            },
        ],
        includeTimestamp: true,
        outputDirectory: undefined, // Will default to home directory (os.homedir())
        useClipboard: true,
    };

    // Run the workflow
    const result = await meetingNotesWorkflow.run(input, desktop);

    console.log('\nüìä Workflow Result:');
    console.log(JSON.stringify(result, null, 2));
}

// Run if executed directly
if (typeof require !== 'undefined' && require.main === module) {
    main().catch(console.error);
}

// Export for use as module
export { InputSchema, meetingNotesWorkflow };
export type { WorkflowInput };

